Wer heute das Stichwort Ruby hört, denkt auch immer automatisch an Ruby on Rails, das Framework für Datenbank-basierte Webanwendungen, welches sich seinen festen Platz im Web-Umfeld erobert hat und inzwischen in Version 2.2 vorliegt. Kaum eine Open-Source-Software dürfte in den letzten Jahren eine ähnliche Wirkung gehabt haben: Fast jede relevante Programmiersprache dürfte inzwischen ihren Rails-Clon haben und die Ideen, die Rails so erfolgreich gemacht haben, wie z.B. Convention over Configuration, haben in den letzten 3 Jahren die Softwareentwicklung auch in anderen Bereichen nachhaltig verändert. Rails selbst hat sich seit der ersten Veröffentlichung in 2004 konstant weiterentwickelt und tut dies weiterhin mit recht hoher Geschwindigkeit - Zuletzt wurden insbesondere die oft kritisierten recht hohen Anforderungen an die Serverhardware, was sowohl Prozessorleistung, als auch Speicherverbrauch angeht, unter die Lupe genommen. Als eines der meist beachtesten Ergebnisse dieser Bemühungen wurde Rails 2.2 komplett als threadsafe deklariert. Eine geeignete Umgebnung (wie z.B. JRuby) vorausgesetzt, können Rails-Anwendungen dadurch wesentlich effizienter betrieben werden.

Die damals fehlende Thread-Safety war es, die Ezra Zygmuntowicz im Herbst 2006 veranlasst, sich ernsthaft mit der Entwicklung einer Alternative zu Rails zu beschäftigen. Das Grundproblem: Da Rails-Anwendungen grundsätzlich immer nur einen Request pro Prozess abarbeiten können, werden insbesondere lang laufenende Requests (wie z.B. große Datei-Uploads) schnell zu einem Problem für einen Anwendungsserver, der ja nur eine endliche Zahl an Rails-Requests starten kann. 

Am 10. Oktober 2006 veröffentlicht Zygmuntowicz die erste, sehr minimale Version seiner Alternative, die zunächst nur einen Request-Handler für den Ruby-Webserver Mongrel darstellt, der in der Lage ist, HTML, genau wie Rails über ERb (Embedded Ruby)-Templates auszuliefern. Er nennt das ganze Merb, was für Mongrel + Erb stehen soll.

Am 8. November 2008, also etwas mehr als zwei Jahre später, kann Zygmuntowicz auf seinem Blog die Veröffentlichung der Version 1.0 von Merb ankündigen. Von dem anfänglichen Minimalismus ist oberflächlich nicht viel übriggeblieben, bei Merb handelt es sich inzwischen um ein ausgewachsenes Framework, welches sich im Featureumfang durchaus mit Rails messen kann.

Die Unterschiede zwischen Rails und Merb werden deutlich, wenn man sich die Zielsetzung der Merb-Entwickler ansieht - Diese Prinzipien ziehen sich wie ein roter Faden durch das gesamte Framework:

- Optimiert für hohe Performanz. Von Anfang an war es das erklärte Ziel der Entwickler, das der Kern von Merb deutlich performanter zu Werke gehen sollte als dies bei Rails der Fall ist. Aus diesem Ziel lassen sich viele andere Designentscheidungen ableiten. Wie bereits berichtet liegt ein Schwerpunkt der momentanen Rails-Entwicklung ebenfalls in der Verbesserung der Performance, allerdings spielte diese beim ursprünglichen Design von Rails keine so große Rolle, was die nachträgliche Optimierung oft schwierig gestaltet.

- Keine Magie. Während Rails an vielen Stellen intensiven Gebrauch von Rubys Metaprogramming-Fähigkeiten macht, wurde bei Merb versucht, weitestgehend darauf zu verzichten. Das Ergebnis ist ein Framework, dessen Quelltext deutlich einfacher lesbar ist. An vielen Stellen dürfte diese Designentscheidung auch zu Performance-Gewinnen beitragen.

- Flexibilität. Während Rails den einen, richtigen Weg vorgibt, wie Web-Anwendungen auszusehen haben, welches Javascript-Framework zu verwenden ist, wie die Dateistruktur einer Anwendung aussieht etc., hält sich Merb an dieser Stelle vornehm zurück. Es gibt zwar auch hier Vorgaben, deren Befolgung die Entwicklung besonders schnell und komfortabel macht, aber es ist (was bei Rails so nicht der Fall ist) recht einfach, diese Vorgaben zu ignorieren, bzw. anzupassen. So existieren Anbindungen für diverse OR-Mapper (unter anderem auch Rails' ActiveRecord), Javascript-Frameworks (u.a. das zur Zeit sehr beliebte jQuery von John Resig). Ausserdem kann die Dateistruktur der Merb-Anwendungen weitgehend den eigenen Bedürfnissen angepasst werden, im Extremfall lässt sich eine Merb-Anwendung sogar in einer einzigen Datei ablegen.

- Hackbarkeit. Es soll für die Benutzer von Merb wesentlich einfacher sein, den Quellcode von Merb zu verstehen, zu erweitern und anzupassen. Hier zahlt die bereits genannte "Keine Magie"-Strategie ein, zusätzlich gibt es sehr klare Vorgaben im Merb-Projekt, wie Code zu dokumentieren ist, ausserdem gibt es eine Unterscheidung zwischen "public" und "private" APIs, die schon in der Dokumentation deutlich machen, auf welche Konstrukte man sich langfristig verlassen kann und welche man besser nicht anfasst.


[Model / OR-Mapper]

Merb ist OR-Mapper-Agnostisch. Es ist für jeden OR-Mapper nur sehr wenig Glue-Code notwendig um ihn in Merb nutzen zu können. Für Rails-Umsteiger böte sich sicher zunächst an, ActiveRecord weiter zu verwenden, was dank der des merb_activerecord-Plugins kein Problem ist. 

Der empfohlene OR-Mapper für Merb ist allerdings DataMapper, der auch vom Merb-Team entwickelt wird. Die Benutzung von DataMapper ist für Programmierer, die sich bereits mit ActiveRecord auskennen, sehr leicht zu verstehen, allerdings gibt es ein paar Grundsätzliche Unterschiede:

- DataMapper-Objekte sind keine Subklassen einer abstrakten Klasse (ActiveRecord::Base), sondern bekommen die Funktionalität über ein Modul injiziert, so dass man beliebige Klassenhierachien aufbauen und über Datamapper persistieren kann. 

- Bei DataMapper werden die Datenbank-Tabellen durch Definitionen im Modell festgelegt, und nicht, wie bei ActiveRecord genau umgekehrt, die Modell-Attribute durch die Struktur der Datenbank-Tabellen. Dies hat einige Implikationen:
- Es ist wesentlich einfacher, Datentypen zu definieren, die von der Datenbank nicht direkt unterstützt werden.
- Die Definition der Datenbankstruktur ist nicht, wie bei ActiveRecord, zwischen den Datenbank-Tabellen und den Modellklassen verteilt. Bei ActiveRecord werden zwar die Spaltennamen und die Datentypen der Spalten automatisch auf Attribute der Modellklasse gemappt, alles andere, wie z.B. Beziehungen zwischen Tabellen bzw. Objekten, müssen dann aber im Code der Modelklasse definiert werden. Bei DataMapper passiert beides in der Modellklasse. (Siehe Beispiele 1 und 2)
- DataMapper kann, ausgehend von den Attribut-Definitionen in den Modell-Klassen automatisch die Datenbank-Tabellen erzeugen, ohne dass wie bei ActiveRecord eine Migration erzeugt werden muss. Diese Auto-Migrationen können sowohl Destruktiv (durch komplettes Löschen und Neu anlegen der Tablle) als auch Non-Destruktiv durchgeführt werden (durch ALTER TABLE-Aufrufe oder ähnliches), wobei die letztere Variante nicht immer zum gewünschten Ergebnis führt. Daher kennt auch DataMapper so etwas wie die von ActiveRecord bekannten Migrationen (Beispiel 3), so dass z.B. zusätzlich Daten-Migrationen vorgenommen werden können. Im produktiven Betrieb wird man diese Auto-Migrationen wohl selten einsetzen können.
- DataMapper führt intern eine sog. Identity Map, welche die Ruby-Objekte 1:1 auf Datenbank-Zeilen mappt, was zu einer effizienteren Speicherauslastung führen kann und gleichzeitig die Benutzung von Standard-Sprachfeatures auf DataMapper-Objekten erst möglich macht. (Siehe Beispiel 4)

[Beispiel 1 (Active Record-Migration und Klassendefinition)]

# Datei: db/migrate/20080729095225_create_universes.rb
class CreateUniverses < ActiveRecord::Migration
  def self.up
    create_table :universes do |t|
      t.text :name
      t.timestamps
    end
  end
  
  def self.down
    drop_table :universes
  end
end
------------
# Datei: db/migrate/20080729095236_create_stars.rb
class CreateStars < ActiveRecord::Migration
  def self.up
    create_table :stars do |t|
      t.text :name
      t.integer :universe_id
      t.float :color
      t.float :x
      t.float :y
      t.timestamps
    end
  end
  def self.down
    drop_table :stars
  end
end
------------
# Datei: app/models/universe.rb
class Universe < ActiveRecord::Base
  has_many :stars
end
------------
# Datei: app/models/stars.rb
class Stars < ActiveRecord::Base
  belongs_to :universe
end

[Beispiel 2: Datamapper Klassendefinition]

# Datei: app/models/universe.rb
class Universe
  include DataMapper::Resource
  property :id, Serial
  property :name, String
  has n, :stars
end
------------
# Datei: app/models/star.rb
class Star
  include DataMapper::Resource
  property :id, Serial
  property :name, String
  property :color, Float
  property :x, Float
  property :y, Float
  belongs_to :universe
end


[Beispiel 3: DataMapper-Migration]
# Datei: schema/migrations/001_add_color_to_stars.rb
migration 1, :add_color_to_stars  do
  up do
    modify_table :stars do |table|
      table.add_column :color, Float
    end
  end
  down do
    modify_table :stars do |table|
      table.drop_column :color
    end    
  end
end

[Beispiel 4: Identity-Maps in Aktion]
@parent = Tree.find(:first, :conditions => ['name = ?', 'bob'])
 
@parent.children.each do |child|
  # Liefert in ActiveRecord false, da neues Objekt erzeugt wird.
  # DataMapper liefert true, da über Identity-Map abgefangen
  puts @parent.object_id == child.parent.object_id
end

Finale Anmerkungen zu DM



[Controller]

Der wichtigste Unterschied von Merb-Controllern zu Rails-Controllern ist, dass der Rückgabewert einer Controller-Action automatisch als Output gerendert wird. Dies führt dazu, das sich Controller-Methoden (bzw. Actions) eher wie "echte" Methoden anfühlen und ermöglicht darüber hinaus, wie wir noch sehen werden, einige nette Konstrukte. Der Unterschied wird in Listing x und y deutlich.

[Beispiel x: die einfachste Art in Rails , einen text zu rendern]
def index
  render :text => 'Hallo Welt'
end
[Beispiel y: Die selbe Action in Merb]
def index
 "Hallo Welt"
end

Eine "render"-Methode gibt es auch in Merb, sie funktioniert ganz ähnlich, nach den selben regeln wie in Rails wird ein passendes Template gesucht und gerendert. Nur muss man, wenn man wirklich ein Template rendern lassen will, dies eben explizit ausdrücken.

def index
  render # rendert app/views/controllername/index.html.erb
end

Auch bei merb gibt es ein Konstrukt, um eine Action Dinge mit verschiedenen Content-Types rendern zu lassen, z.B. als HTML oder als XML oder als JSON. Die Konstrukte unterscheiden sich jedoch deutlich. In Merb gibt es eine Methode namens "display", die versucht, die übergebenen Daten transparent auf die anzubietenden Content-types zu mappen. Im Beispiel X/Y sind die unterschiedlichen Vorgehensweisen zu sehen.

blah blah controller #TODO echten, getesteten code
def index
  @stars = @universe.stars.find(:all)
  rensponds_to do |format|
    format.xml { @stars.to_xml }
    format.json { @starts.to_json }
    format.html
  end
end

provides :xml, :json
def index
  @stars = @universe.stars.find(:all)
  display @stars
end

Auch die display-Methode ruft die "to_xml" und "to_json"-Methoden auf, die Schreibweise ist jedoch erkennbar kompakter. 

Die entsprechnenden Transformations-Methoden (to_xml / to_json) werden übrigens von den OR-Mappern bzw. von den Bibliotheken zur Verfügung gestellt, man kann diese natürlich auch überschreiben. 

Da es Situationen gibt, in denen ein einfaches Aufrufen der Transformations-Methoden nicht ausreichen wird, kann auch eine Merb-Action abhängig vom Content-Type verzweigen, Merb bedient sich dort aber der klassischen Case-Anweisung (siehe Beispiel drei)

[Beispiel 3 - Merbs variante von responds_to]

case content_type 
when :xml
  # mehr krams hier
  display @stars
when :yaml 
  display @stars
else
  # und noch was
  render 
end 

[Rendern und dann noch was]

Etwas, das in Rails gar nicht möglich ist, bietet die "render_then_call"-Methode, mit der man Prozesse, die an einer Action hängen, erst nach dem Ausliefern einer Antwortseite ausführen kann. Dies ist in Rails nur mit speziellen Lösungen wie BackgroundJob / DelayedJob etc. möglich.

def show
  render_then_call(display @star) do
		Stats.tick(@star)
	end
end

Allerding sollte man darauf achten, dass diese Methoden weiterhin im Kontext des Merb-Prozesses laufen und sich daher diese Variante nur für kurzlaufende Prozesse eignet, mit deren Ausführung man dennoch nicht die Auslieferung zum Client behindern möchte. Länger laufende Prozesse werden dann besser wieder über z.B. über Queues gelöst.

Zuletzt noch ein Hinweis auf ein sehr interessantes Merb-Plugin namens merb-action-args, welches standardmäßig mit Merb 1.0 installiert wird. Dieses ermöglicht es, Request-Parameter direkt als Methoden-Parameter zu empfangen.

def show
  display Start.find(params[id])
end

def show(id)
  display Star.find(id)
end

Da zur Umsetzung dieser Funktionalität einiges an Ruby-Introspektions-Magie notwendig ist, kann dieses an sich sehr schöne Plugin leider nicht vorbehaltlos empfohlen werden (was vermutlich auch der Grund ist, warum es sich nicht um eine Standard-Funktionalität von merb-core handelt)

[Router]

Das URL-Routing, also die Zuordnung von URLs zu den Controller-Klassen und Action-Methoden, ist eines der Sahnestücke von Merb. In Merb ist es üblich, deutlich mehr Logik bereits im Routing auszudrücken, als dies in Rails der Fall ist.

Die Syntax zur Erzeugung von Routen ist etwas anders als in Rails, zumindest für Nicht-REST-Routen, ist aber doch recht einfach verständlich, wenn man die Rails-Routen kennt.

map.foo "/foo/:foo_id", :controller => 'foo', :action => :show

match("/foo/:foo_id").to(:controller => 'foo', :action => :show).name(:foo)

Der Parameter :foo_id wird automatisch aus der URL extrahiert und dem Request als Parameter angefügt.

Zusätzlich zu dieser einfachen Variante kann man nun dem match-Aufruf aber auch noch weitere Parameter als Hash übergeben, so z.B.:

match(:path => "/foo", :user_agent => /iPhone/).to(:controller => 'foo', :action => :index_for_iphone)

Als Parameter können hier alle Methoden, die im Request-Objekt zur Verfügung gestellt werden, benutzt werden, z.B. :domain, :subdomains, :user_agent, etc.

Genau wie bei Rails ist es möglich, REST-Ressourcen zu definieren und sogar zu verschachteln. Auch hier ist die Syntax leicht anders:

map.resources :stars do |star|
  star.resources :planets
end

resources :stars do
  resources :planets
end

Zusätzlich zu der deutlich gesteigerten Flexibilität der Merb-Routen (deren komplette Beschreibung den Umfang dieses Artikels sprengen würde) ist die Umsetzung der Routen offensichtlich deutlich performanter als in Rails (wobei der Vorsprung durch die Änderungen in den letzten Rails-Versionen deutlich verringert wurde).


[Erzeugung von URLs]

Anders als bei Rails werden durch den Router keine benannten Methoden erzeugt. Statt dessen gibt es zwei Methoden, die zur Erzeugung von URLs verwendet werden. "url" erzeugt URLs aus dem Namen einer Route, während resource() eine URL für REST-Ressourcen erzeugt.

url(:foo, :foo_id => 'fooid') => '/foo/fooid'
resource(:stars) => '/stars'
resource(@star) => '/stars/12'
resource(@star, :planets) => '/stars/planets'
resource(@star, @planet) => '/stars/planets'

[Views]

Im View-Layer unterscheidet sich Merb kaum von Rails. Standardmäßig werden ERb-, haml und Builder-Templates unterstützt. Mit Hilfe einer Konfigration in config/init.rb kann man den Generatoren beibringen, z.B. Standardmäßig haml-Templates zu erzeugen:

use_template_engine :haml

Unterschiede zu Rails finden sich im Detail in der Bennenung von vier-helper-methoden (z.B. zum Erzeugen von Formularen und Formularfeldern), so zu sehen im Beispiel x

<% form_for(@star) do |f| %>
  <p><%= f.label :name %><%= f.text_field :name %></p>
  <p><%= f.label :owner %><%= f.text_field :owner %></p>
  <p><%= submit_tag "Update" %></p>
<% end %>

<%= form_for(@star, :action => resource(@star)) do %>
  <p><%= text_field :name, :label => "Name"  %></p>
  <p><%= text_field :owner, :label => "Owner"  %></p>
  <p><%= submit "Update" %></p>
<% end =%>


[Parts]

In früheren Rails-Versionen gab es die sog. Komponenten, die, vor allem wegen der schlechten Performance, im Laufe der Entwicklung aus dem Rails-Core geflogen sind. Etwas ganz ähnliches gibt es, in einer performanten Variante, als Plugin für Merb, in Form der sog. Parts. Parts sind im Wesentlichen eigene Controller, die eigene View-Templates haben und dann als "Widgets" in andere Views eingebaut werden können. Beispiel 3 zeigt ein solches Part



[Slices]

Noch einen Schritt weiter in Richtung der Wiederverwendung von Komponenten gehen die sog. Slices. Slices sind komplette Merb-Applikationen, die sich als ruby-gem verpackt in eine Anwendung einbinden lassen. Ein Beispiel für eine solche Slice ist das merb-auth-slice-password gem, welches für das merb-auth-Plugin Anmelde- und Registrierungsformulare implementiert.

[Deployment]

Die Anbindung von Merb an Applikationswebserver basiert auf der Rack-Bibliothek von Christian Neukirchen. Für Rack existieren wiederum Anbindungen an Zahlreiche Webserver und -Umgebungen, wie z.B. Mongrel, Thin, FastCGI, SCGI, mod_passenger usw., so dass der Betrieb mindestens in allen Umgebungen, die Rails-Anwendungen unterstützen theoretisch möglich sein sollte.

Für den eigentlichen Deployment-Vorgang bietet sich das im Rails-Umfeld populäre Tool Capistrano an, für welches bereits Rezepte im Merb-Wiki zu finden sind.

[Literatur / Hilfe]

Die vorhandene Literatur und Dokumentation ist zur Zeit noch Merbs große Schwäche. 

Zum Zeitpunkt da diese Worte geschrieben werden sind vier echte Bücher über Merb angekündigt, von denen zwei auch bereits im Rahmen von Early-Access-Programmen in elektronischer Form gelesen werden können. Zusätzlich schreibt Geoffrey Grossenbach noch an der finalen Version des EBooks "Meet Merb", welche spätestens bei Erscheinen dieses Artikels fertig sein sollte.

Die Online-Dokumentation von Merb ist zur Zeit ebenfalls eher dürftig: Während es durchaus brauchbare (wenn auch manchmal noch etwas dünne) RDoc-Dokumentationen zu den Merb-Bibliotheken gibt, sind darüber hinaus gehende Informationen (Tutorials/Howtos) noch sehr dünn gesäht. Im Merb-Wiki gibt es durchaus schon gute Ansätze, die Konzepte von Merb zu erklären, aufgrund der hohen Fluktuation der Merb-API vor Herausgabe der Version 1.0 war es jedoch nicht möglich, diese Informationen allzuweit zu vervollständigen. Hier ist die Community gefragt, dem Beispiel von Rails zu folgen (Auch wenn manche die Dokumentation von Rails immer noch als größten Schwachpunkt sehen). 

Ein Vorteil den Merb an dieser Stelle haben dürfte, ist, das die Hürde, sich in den Quelltext des Frameworks einzulesen, um eine Funktion zu verstehen, wesentlich geringer sein sollte als bei Rails.

[fazit]

Merb ist ein ausgereiftes und durchdachtes Framework, das bereits zahlreich produktiv im Einsatz ist. Wie bei einem so jungen OpenSource-Framework nicht anders zu erwarten, erfüllen Dokumentation und Literatur noch nicht alle Ansprüche. Für Entwickler, die öfter mal an die Grenzen von Rails stoßen, oder aber sich von dem engen Korsett an Ideen und Frameworks, welches einem von Rails vorgegeben wird, eingeengt fühlt, ist Merb sicher einen Blick wert.

[Mitmachen]

Merb hat eine sehr aktive Entwickler-Gemeinschaft. Anders als Rails gibt es kein offiziell berufenes Core-Team sondern die Entwicklung wird von ein paar Mitarbeitern von Engine Yard dezentral über GitHub organisiert.

[Quellen]

- merb-peepcode-buch
- merbivore.com
- 

